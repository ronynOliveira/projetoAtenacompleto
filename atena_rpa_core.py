# nome do arquivo: atena_rpa_core.py (v4.0 - Core Unificado de RPA com IA)import reimport jsonimport base64import asynciofrom typing import List, Dict, Optional, Any, Tuplefrom playwright.async_api import Page, ElementHandle, TimeoutError as PlaywrightTimeoutError, async_playwright, Browserimport timeimport osimport loggingfrom datetime import datetimeimport threadingimport requestsfrom dataclasses import dataclass, asdictfrom enum import Enumimport cv2import numpy as npfrom PIL import Imageimport ioimport hashlibfrom pathlib import Path# Configuração avançada do Loggerlogging.basicConfig(    level=logging.INFO,    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    handlers=[        logging.FileHandler('rpa_framework.log'),        logging.StreamHandler()    ])logger = logging.getLogger(__name__)# --- Enums e Estruturas de Dados ---class ChangeType(Enum):    LAYOUT_CHANGE = "layout_change"    NEW_CAPTCHA = "new_captcha"    LOGIN_FLOW_CHANGE = "login_flow_change"    ELEMENT_MOVED = "element_moved"    CONTENT_BLOCKED = "content_blocked"    BOT_DETECTION = "bot_detection"@dataclassclass PageState:    url: str    title: str    dom_hash: str    screenshot_hash: str    elements_count: int    timestamp: datetime    captcha_detected: bool = False    login_required: bool = False    bot_detection_score: float = 0.0@dataclassclass AdaptationStrategy:    strategy_type: str    confidence: float    selectors: List[str]    actions: List[Dict]    fallback_options: List[str]# --- Classes de IA e Análise Visual ---class AIVisionAnalyzer:    """Análise visual inteligente usando IA para detectar mudanças e elementos."""        def __init__(self):        self.vision_cache = {}            def analyze_page_changes(self, current_screenshot: bytes, previous_screenshot: bytes = None) -> Dict[str, Any]:        """Analisa mudanças visuais na página usando computer vision."""        try:            current_img = self._bytes_to_cv2(current_screenshot)                        analysis = {                'captcha_detected': self._detect_captcha(current_img),                'login_form_detected': self._detect_login_form(current_img),                'bot_detection_indicators': self._detect_bot_protection(current_img),                'layout_changes': []            }                        if previous_screenshot:                previous_img = self._bytes_to_cv2(previous_screenshot)                analysis['layout_changes'] = self._compare_layouts(current_img, previous_img)                            return analysis        except Exception as e:            logger.error(f"Erro na análise visual: {e}")            return {'error': str(e)}        def _bytes_to_cv2(self, img_bytes: bytes) -> np.ndarray:        """Converte bytes de imagem para formato OpenCV."""        img_array = np.frombuffer(img_bytes, np.uint8)        return cv2.imdecode(img_array, cv2.IMREAD_COLOR)        def _detect_captcha(self, img: np.ndarray) -> bool:        """Detecta CAPTCHAs usando análise de padrões visuais."""        # Detecção de texto estilizado típico de CAPTCHA        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)                # Busca por características típicas de CAPTCHA        edges = cv2.Canny(gray, 50, 150)        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)                captcha_indicators = 0        for contour in contours:            area = cv2.contourArea(contour)            # CAPTCHAs geralmente têm áreas específicas            if 500 < area < 5000:                x, y, w, h = cv2.boundingRect(contour)                aspect_ratio = w / h                # Típica proporção de CAPTCHAs                if 2 < aspect_ratio < 6:                    captcha_indicators += 1                return captcha_indicators > 3        def _detect_login_form(self, img: np.ndarray) -> bool:        """Detecta formulários de login através de análise visual."""        # Implementação simplificada - detecta campos típicos de login        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)                # Template matching para elementos comuns de login        # Isso poderia ser expandido com templates reais        height, width = gray.shape                # Busca por retângulos que podem ser campos de input        edges = cv2.Canny(gray, 30, 100)        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)                input_like_shapes = 0        for contour in contours:            area = cv2.contourArea(contour)            if 1000 < area < 10000:  # Tamanho típico de campos de input                x, y, w, h = cv2.boundingRect(contour)                aspect_ratio = w / h                if 3 < aspect_ratio < 15:  # Proporção típica de campos de texto                    input_like_shapes += 1                return input_like_shapes >= 2  # Pelo menos 2 campos (usuário e senha)        def _detect_bot_protection(self, img: np.ndarray) -> List[str]:        """Detecta indicadores de proteção anti-bot."""        indicators = []                # Análise de texto para palavras-chave comuns        # Em uma implementação real, usaria OCR (tesseract/easyocr)                # Análise de padrões visuais típicos de proteções        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)                # Cloudflare challenge pattern        if self._detect_cloudflare_pattern(gray):            indicators.append("cloudflare_challenge")                # reCAPTCHA pattern        if self._detect_recaptcha_pattern(gray):            indicators.append("recaptcha")                    return indicators        def _detect_cloudflare_pattern(self, gray_img: np.ndarray) -> bool:        """Detecta padrões visuais típicos do Cloudflare."""        # Implementação simplificada        return False        def _detect_recaptcha_pattern(self, gray_img: np.ndarray) -> bool:        """Detecta reCAPTCHA através de padrões visuais."""        # Implementação simplificada        return False        def _compare_layouts(self, img1: np.ndarray, img2: np.ndarray) -> List[Dict]:        """Compara layouts de duas imagens para detectar mudanças."""        changes = []                # Redimensiona imagens para comparação        height, width = min(img1.shape[0], img2.shape[0]), min(img1.shape[1], img2.shape[1])        img1_resized = cv2.resize(img1, (width, height))        img2_resized = cv2.resize(img2, (width, height))                # Calcula diferença        diff = cv2.absdiff(img1_resized, img2_resized)        gray_diff = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)                # Encontra regiões com mudanças significativas        _, thresh = cv2.threshold(gray_diff, 30, 255, cv2.THRESH_BINARY)        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)                for contour in contours:            area = cv2.contourArea(contour)            if area > 1000:  # Apenas mudanças significativas                x, y, w, h = cv2.boundingRect(contour)                changes.append({                    'type': 'layout_change',                    'region': {'x': int(x), 'y': int(y), 'width': int(w), 'height': int(h)},                    'area': int(area)                })                return changesclass IntelligentSelectorGenerator:    """Gera seletores inteligentes usando múltiplas estratégias."""        def __init__(self):        self.selector_cache = {}        self.success_history = {}        def generate_robust_selectors(self, page: Page, element_description: str) -> List[str]:        """Gera múltiplos seletores robustos para um elemento."""        selectors = []                # Estratégias baseadas em diferentes atributos        strategies = [            self._generate_by_text_content,            self._generate_by_semantic_attributes,            self._generate_by_visual_position,            self._generate_by_context,            self._generate_by_accessibility_attributes        ]                for strategy in strategies:            try:                strategy_selectors = strategy(page, element_description)                selectors.extend(strategy_selectors)            except Exception as e:                logger.debug(f"Estratégia falhou: {strategy.__name__}: {e}")                # Remove duplicatas e ordena por confiabilidade        unique_selectors = list(dict.fromkeys(selectors))        return self._rank_selectors_by_reliability(unique_selectors, element_description)        def _generate_by_text_content(self, page: Page, description: str) -> List[str]:        """Gera seletores baseados no conteúdo de texto."""        selectors = []                # Diferentes variações para campos de entrada        if 'prompt' in description.lower() or 'input' in description.lower():            text_variations = [                'textarea[placeholder*="message" i]',                'input[placeholder*="type" i]',                'textarea[aria-label*="message" i]',                '[data-testid*="input"]',                '[data-testid*="prompt"]',                'textarea:not([style*="display: none"])',                'input[type="text"]:not([style*="display: none"])'            ]            selectors.extend(text_variations)                return selectors        def _generate_by_semantic_attributes(self, page: Page, description: str) -> List[str]:        """Gera seletores baseados em atributos semânticos."""        selectors = []                # Atributos de acessibilidade e semânticos        semantic_selectors = [            '[role="textbox"]',            '[aria-multiline="true"]',            '[contenteditable="true"]',            'textarea[required]',            'input[required]'        ]                selectors.extend(semantic_selectors)        return selectors        def _generate_by_visual_position(self, page: Page, description: str) -> List[str]:        """Gera seletores baseados na posição visual."""        selectors = []                # Seletores baseados em posição relativa        position_selectors = [            'textarea:first-of-type',            'textarea:last-of-type',            'form textarea',            'main textarea',            '.chat-input textarea',            '.message-input textarea'        ]                selectors.extend(position_selectors)        return selectors        def _generate_by_context(self, page: Page, description: str) -> List[str]:        """Gera seletores baseados no contexto da página."""        selectors = []                try:            # Analisa o contexto da página            page_title = page.title().lower()            page_url = page.url.lower()                        # Seletores específicos por contexto            if 'chat' in page_title or 'chat' in page_url:                chat_selectors = [                    '[data-id="root"]',                    '.chat-composer textarea',                    '.conversation-input textarea'                ]                selectors.extend(chat_selectors)                        if 'claude' in page_url:                claude_selectors = [                    'textarea[data-id="root"]',                    '.ProseMirror',                    '[data-testid="conversation-input"]'                ]                selectors.extend(claude_selectors)                        except Exception as e:            logger.debug(f"Erro ao gerar seletores por contexto: {e}")                return selectors        def _generate_by_accessibility_attributes(self, page: Page, description: str) -> List[str]:        """Gera seletores baseados em atributos de acessibilidade."""        return [            '[aria-describedby]',            '[aria-labelledby]',            'textarea[aria-expanded]',            'input[aria-expanded]'        ]        def _rank_selectors_by_reliability(self, selectors: List[str], description: str) -> List[str]:        """Ordena seletores por confiabilidade baseada em histórico."""        scored_selectors = []                for selector in selectors:            score = 1.0  # Score base                        # Aumenta score baseado em histórico de sucesso            history_key = f"{description}:{selector}"            if history_key in self.success_history:                success_rate = self.success_history[history_key]['successes'] / max(1, self.success_history[history_key]['attempts'])                score *= (1 + success_rate)                        # Penaliza seletores muito genéricos            if selector.count(' ') == 0 and len(selector) < 10:                score *= 0.8                        # Favorece seletores com atributos específicos            if any(attr in selector for attr in ['data-testid', 'data-id', 'aria-label']):                score *= 1.3                        scored_selectors.append((selector, score))                # Ordena por score decrescente        scored_selectors.sort(key=lambda x: x[1], reverse=True)        return [selector for selector, _ in scored_selectors]        def record_selector_result(self, selector: str, description: str, success: bool):        """Registra resultado de uso de seletor para aprendizado."""        history_key = f"{description}:{selector}"                if history_key not in self.success_history:            self.success_history[history_key] = {'successes': 0, 'attempts': 0}                self.success_history[history_key]['attempts'] += 1        if success:            self.success_history[history_key]['successes'] += 1class AdaptiveAntiDetectionSystem:    """Sistema inteligente para evitar detecção de bots."""        def __init__(self):        self.human_patterns = self._load_human_patterns()        self.detection_indicators = []        def _load_human_patterns(self) -> Dict[str, Any]:        """Carrega padrões de comportamento humano."""        return {            'typing_speeds': [0.05, 0.15, 0.08, 0.12, 0.07],  # Variação na velocidade de digitação            'mouse_movements': 'bezier',  # Tipo de movimento do mouse            'scroll_patterns': 'organic',  # Padrões de rolagem            'pause_patterns': [0.5, 1.2, 0.8, 2.0, 0.3]  # Pausas entre ações        }        async def configure_stealth_browser(self, browser_args: Dict) -> Dict:        """Configura navegador com recursos anti-detecção."""        stealth_args = {            'user_agent': self._get_realistic_user_agent(),            'viewport': {'width': 1366, 'height': 768},  # Resolução comum            'locale': 'pt-BR',            'timezone_id': 'America/Sao_Paulo',            'extra_http_headers': {                'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8',                'Accept-Encoding': 'gzip, deflate, br',                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',                'DNT': '1',                'Connection': 'keep-alive',                'Upgrade-Insecure-Requests': '1'            }        }                # Merge com argumentos fornecidos        stealth_args.update(browser_args)        return stealth_args        def _get_realistic_user_agent(self) -> str:        """Retorna user agent realista e atualizado."""        # Em produção, isso deveria ser atualizado dinamicamente        return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"        async def human_like_typing(self, page: Page, element: ElementHandle, text: str):        """Simula digitação humana com variações naturais."""        await element.click()        await asyncio.sleep(0.1)                for i, char in enumerate(text):            await element.type(char)                        # Variação na velocidade de digitação            speed_variation = np.random.choice(self.human_patterns['typing_speeds'])            await asyncio.sleep(speed_variation)                        # Pausas ocasionais (como humanos fazem)            if i > 0 and i % 15 == 0:                pause = np.random.choice(self.human_patterns['pause_patterns'])                await asyncio.sleep(pause)        async def human_like_scroll(self, page: Page, direction: str = 'down', distance: int = 300):        """Simula rolagem humana natural."""        # Movimento orgânico de scroll em pequenos incrementos        steps = distance // 50        for _ in range(steps):            await page.mouse.wheel(0, 50 if direction == 'down' else -50)            await asyncio.sleep(np.random.uniform(0.1, 0.3))class ChangeDetectionSystem:    """Sistema para detectar e adaptar-se a mudanças nos sites."""        def __init__(self):        self.baseline_states = {}        self.change_history = []        self.adaptation_strategies = {}        def capture_baseline(self, page: Page, site_identifier: str) -> PageState:        """Captura estado baseline de uma página."""        try:            screenshot = page.screenshot()            dom_content = page.content()                        state = PageState(                url=page.url,                title=page.title(),                dom_hash=hashlib.md5(dom_content.encode()).hexdigest(),                screenshot_hash=hashlib.md5(screenshot).hexdigest(),                elements_count=len(page.query_selector_all('*')),                timestamp=datetime.now()            )                        self.baseline_states[site_identifier] = state            logger.info(f"Baseline capturado para {site_identifier}")            return state                        except Exception as e:            logger.error(f"Erro ao capturar baseline: {e}")            raise        def detect_changes(self, page: Page, site_identifier: str) -> List[ChangeType]:        """Detecta mudanças comparando com baseline."""        if site_identifier not in self.baseline_states:            logger.warning(f"Sem baseline para {site_identifier}")            return []                baseline = self.baseline_states[site_identifier]        current_screenshot = page.screenshot()        current_dom = page.content()                changes = []                # Detecção de mudanças no DOM        current_dom_hash = hashlib.md5(current_dom.encode()).hexdigest()        if current_dom_hash != baseline.dom_hash:            changes.append(ChangeType.LAYOUT_CHANGE)                # Detecção visual usando IA        vision_analyzer = AIVisionAnalyzer()        baseline_screenshot = self._load_baseline_screenshot(site_identifier)                if baseline_screenshot:            visual_analysis = vision_analyzer.analyze_page_changes(                current_screenshot, baseline_screenshot            )                        if visual_analysis.get('captcha_detected'):                changes.append(ChangeType.NEW_CAPTCHA)                        if visual_analysis.get('login_form_detected'):                changes.append(ChangeType.LOGIN_FLOW_CHANGE)                        if visual_analysis.get('bot_detection_indicators'):                changes.append(ChangeType.BOT_DETECTION)                self.change_history.append({            'timestamp': datetime.now(),            'site': site_identifier,            'changes': changes        })                return changes        def _load_baseline_screenshot(self, site_identifier: str) -> Optional[bytes]:        """Carrega screenshot baseline salvo."""        try:            screenshot_path = f"baselines/{site_identifier}_screenshot.png"            if os.path.exists(screenshot_path):                with open(screenshot_path, 'rb') as f:                    return f.read()        except Exception as e:            logger.debug(f"Erro ao carregar screenshot baseline: {e}")        return None        def generate_adaptation_strategy(self, changes: List[ChangeType], site_identifier: str) -> AdaptationStrategy:        """Gera estratégia de adaptação baseada nas mudanças detectadas."""        # Esta é uma versão simplificada - em produção seria muito mais sofisticada                if ChangeType.NEW_CAPTCHA in changes:            return AdaptationStrategy(                strategy_type="captcha_handling",                confidence=0.8,                selectors=["iframe[src*='recaptcha']", ".captcha-container"],                actions=[{"type": "wait_for_manual", "timeout": 60}],                fallback_options=["notify_user", "retry_later"]            )                if ChangeType.LOGIN_FLOW_CHANGE in changes:            return AdaptationStrategy(                strategy_type="login_adaptation",                confidence=0.7,                selectors=["input[type='email']", "input[type='password']", "button[type='submit']"],                actions=[{"type": "rediscover_elements"}, {"type": "update_selectors"}],                fallback_options=["manual_intervention"]            )                # Estratégia padrão para mudanças de layout        return AdaptationStrategy(            strategy_type="layout_adaptation",            confidence=0.6,            selectors=[],            actions=[{"type": "regenerate_selectors"}, {"type": "visual_search"}],            fallback_options=["fallback_selectors", "user_notification"]        )# --- Framework Principal Melhorado ---class AdvancedAIExecutorFramework:    """Framework avançado com IA para automação robusta."""        def __init__(self, ai_type: str):        self.ai_type = ai_type        self.browser_manager = IntelligentBrowserManager()        self.page: Optional[Page] = None        self.selector_generator = IntelligentSelectorGenerator()        self.anti_detection = AdaptiveAntiDetectionSystem()        self.change_detector = ChangeDetectionSystem()        self.vision_analyzer = AIVisionAnalyzer()        self.execution_metrics = {}        self.retry_strategies = []            async def execute_prompt_advanced(self, prompt: str, **kwargs) -> Dict[str, Any]:        """Execução avançada com IA e adaptação automática."""        start_time = time.time()        max_retries = kwargs.get('max_retries', 3)                for attempt in range(max_retries):            try:                logger.info(f"AIExecutor[{self.ai_type}]: Tentativa {attempt + 1}/{max_retries}")                                # Inicialização robusta                if not self.page:                    self.page = await self._initialize_advanced_browser(**kwargs) # Make sure this is awaited                                # Detecção de mudanças                site_id = self._get_site_identifier()                changes = self.change_detector.detect_changes(self.page, site_id)                                if changes:                    logger.info(f"Mudanças detectadas: {changes}")                    adaptation = self.change_detector.generate_adaptation_strategy(changes, site_id)                    await self._apply_adaptation_strategy(adaptation)                                # Busca inteligente por elementos                prompt_selectors = self.selector_generator.generate_robust_selectors(                    self.page, "campo_prompt"                )                                prompt_element = await self._find_element_with_multiple_strategies(prompt_selectors)                if not prompt_element:                    raise Exception("Campo de prompt para '{self.ai_type}' não encontrado.")                                # Digitação humanizada                await self.anti_detection.human_like_typing(self.page, prompt_element, prompt)                                # Submissão com verificação                await self._smart_submit()                                # Aguarda resposta com monitoramento inteligente                response = await self._wait_for_response_with_ai_monitoring()                                execution_time = time.time() - start_time                                # Atualiza histórico de sucesso                for selector in prompt_selectors:                    self.selector_generator.record_selector_result(selector, "campo_prompt", True)                                return {                    'success': True,                    'response': response,                    'execution_time_s': execution_time,                    'ai_type': self.ai_type,                    'prompt': prompt,                    'attempt': attempt + 1,                    'changes_detected': changes,                    'selectors_used': prompt_selectors[:3]  # Top 3 seletores usados                }                            except Exception as e:                logger.error(f"Tentativa {attempt + 1} falhou: {e}")                                if attempt < max_retries - 1:                    # Coleta evidências e tenta recuperação                    evidence = await self._collect_advanced_failure_evidence(e)                    await self._attempt_recovery(evidence)                                        # Espera antes da próxima tentativa                    await asyncio.sleep(2 ** attempt)  # Backoff exponencial                else:                    # Última tentativa falhou                    execution_time = time.time() - start_time                    evidence = await self._collect_advanced_failure_evidence(e)                                        return {                        'success': False,                        'error': str(e),                        'execution_time_s': execution_time,                        'ai_type': self.ai_type,                        'prompt': prompt,                        'attempts': max_retries,                        'failure_evidence': evidence,                        'suggested_actions': self._generate_recovery_suggestions(evidence)                    }        async def _initialize_advanced_browser(self, **kwargs):        """Inicialização avançada do navegador com anti-detecção."""        browser_config = await self.anti_detection.configure_stealth_browser(            kwargs.get('browser_config', {})        )                # Inicializa com configurações anti-detecção        # Ensure this is awaited and returns a Page object        return await self.browser_manager.initialize_browser(**browser_config)        async def _inject_humanization_scripts(self):        """Injeta scripts para mascarar automação."""        humanization_script = """        // Remove indicadores de automação        Object.defineProperty(navigator, 'webdriver', {get: () => undefined});        Object.defineProperty(navigator, 'plugins', {get: () => [1, 2, 3, 4, 5]});        Object.defineProperty(navigator, 'languages', {get: () => ['pt-BR', 'pt', 'en']});                // Simula interações humanas        window.addEventListener('mousemove', function(e) {            // Adiciona pequenas variações naturais no movimento do mouse        });        """                await self.page.add_init_script(humanization_script)        async def _find_element_with_multiple_strategies(self, selectors: List[str]) -> Optional[ElementHandle]:        """Busca elemento usando múltiplas estratégias."""        for i, selector in enumerate(selectors):            try:                element = await self.page.wait_for_selector(selector, timeout=5000)                if element:                    logger.info(f"Elemento encontrado com seletor {i+1}: {selector}")                    return element            except PlaywrightTimeoutError:                continue                # Se seletores falharam, tenta busca visual        return await self._visual_element_search("input_field")        async def _visual_element_search(self, element_type: str) -> Optional[ElementHandle]:        """Busca visual por elementos usando IA."""        try:            screenshot = await self.page.screenshot()                        # Análise visual para encontrar elementos            visual_analysis = self.vision_analyzer.analyze_page_changes(screenshot)                        # Esta é uma implementação simplificada            # Em produção, usaria modelos de IA mais sofisticados            if element_type == "input_field":                # Tenta seletores genéricos baseados na análise                generic_selectors = [                    'textarea:visible',                    'input[type="text"]:visible',                    '[contenteditable="true"]:visible'                ]                                for selector in generic_selectors:                    try:                        element = await self.page.wait_for_selector(selector, timeout=2000)                        if element:                            return element                                            except PlaywrightTimeoutError:                        continue                        return None                        except Exception as e:            logger.error(f"Erro na busca visual: {e}")            return None        async def _smart_submit(self):        """Submissão inteligente com detecção de método correto."""        # Estratégias de submissão em ordem de preferência        submit_strategies = [            ("Enter key", lambda: self.page.keyboard.press('Enter')),            ("Ctrl+Enter", lambda: self.page.keyboard.press('Control+Enter')),            ("Submit button", self._find_and_click_submit_button),            ("Form submission", self._submit_form)        ]                for strategy_name, strategy_func in submit_strategies:            try:                logger.info(f"Tentando submissão: {strategy_name}")                # Await the function call if it's an async function                if asyncio.iscoroutinefunction(strategy_func):                    await strategy_func()                else:                    strategy_func()                                # Verifica se a submissão funcionou                await asyncio.sleep(1)                if await self._submission_successful():                    logger.info(f"Submissão bem-sucedida com: {strategy_name}")                    return                            except Exception as e:                logger.debug(f"Estratégia {strategy_name} falhou: {e}")                continue                raise Exception("Todas as estratégias de submissão falharam")        async def _find_and_click_submit_button(self):        """Encontra e clica no botão de submissão."""        submit_selectors = [            'button[type="submit"]',            'input[type="submit"]',            'button:has-text("Send")',            'button:has-text("Submit")',            'button:has-text("Enviar")',            '[data-testid*="submit"]',            '[data-testid*="send"]',            '.submit-button',            '.send-button'        ]                for selector in submit_selectors:            try:                button = await self.page.wait_for_selector(selector, timeout=2000)                if button:                    await button.click()                    return            except PlaywrightTimeoutError:                continue                raise Exception("Botão de submissão não encontrado")        async def _submit_form(self):        """Submete o formulário diretamente."""        forms = await self.page.query_selector_all('form')        if forms:            await forms[0].evaluate('form => form.submit()')        else:            raise Exception("Nenhum formulário encontrado")        async def _submission_successful(self) -> bool:        """Verifica se a submissão foi bem-sucedida."""        # Indicadores de submissão bem-sucedida        success_indicators = [            # Mudança no conteúdo da página            lambda: self.page.wait_for_function("document.readyState === 'complete'", timeout=3000),            # Aparecimento de indicador de carregamento            lambda: self.page.wait_for_selector('.loading, .spinner, [aria-label*="loading"]', timeout=3000),            # Mudança na URL            lambda: self.page.wait_for_url(lambda url: url != self.page.url, timeout=3000)        ]                for indicator in success_indicators:            try:                await indicator()                return True            except PlaywrightTimeoutError:                continue                return False        async def _wait_for_response_with_ai_monitoring(self) -> str:        """Aguarda resposta com monitoramento inteligente."""        max_wait_time = 120  # 2 minutos máximo        check_interval = 2   # Verifica a cada 2 segundos                start_time = time.time()        last_content_length = 0        stable_count = 0                while time.time() - start_time < max_wait_time:            try:                # Verifica indicadores de resposta em progresso                loading_indicators = await self.page.query_selector_all(                    '.loading, .spinner, .generating, [aria-label*="generating"], [aria-label*="thinking"]'                )                                if loading_indicators:                    logger.info("Resposta em progresso...")                    await asyncio.sleep(check_interval)                    continue                                # Verifica mudanças no conteúdo                current_content = await self.page.content()                current_length = len(current_content)                                if current_length > last_content_length:                    last_content_length = current_length                    stable_count = 0                    logger.debug(f"Conteúdo cresceu para {current_length} caracteres")                else:                    stable_count += 1                                # Se o conteúdo ficou estável por tempo suficiente                if stable_count >= 3:  # 6 segundos estável                    response_text = await self._extract_response_text()                    if response_text and len(response_text.strip()) > 10:                        return response_text                                await asyncio.sleep(check_interval)                            except Exception as e:                logger.error(f"Erro durante monitoramento: {e}")                await asyncio.sleep(check_interval)                # Timeout atingido - tenta extrair o que tiver        logger.warning("Timeout na espera da resposta, extraindo conteúdo atual")        return await self._extract_response_text() or "Timeout na obtenção da resposta"        async def _extract_response_text(self) -> str:        """Extrai o texto da resposta usando múltiplas estratégias."""        extraction_strategies = [            # Seletores específicos para respostas de IA            ('.response-content', 'textContent'),            ('.ai-response', 'textContent'),            ('.message-content', 'textContent'),            ('.chat-message:last-child', 'textContent'),            ('[data-testid="conversation-turn-output"]', 'textContent'),                        # Seletores mais genéricos            ('.markdown-content', 'innerHTML'),            ('pre code', 'textContent'),            ('.prose', 'textContent')        ]                for selector, property_name in extraction_strategies:            try:                elements = await self.page.query_selector_all(selector)                if elements:                    # Pega o último elemento (resposta mais recente)                    last_element = elements[-1]                    text = await last_element.evaluate(f'el => el.{property_name}')                    if text and len(text.strip()) > 10:                        return text.strip()            except Exception as e:                logger.debug(f"Estratégia {selector} falhou: {e}")                continue                # Fallback: pega mudanças recentes no DOM        return await self._extract_recent_dom_changes()        async def _extract_recent_dom_changes(self) -> str:        """Extrai mudanças recentes no DOM como fallback."""        try:            # JavaScript para encontrar elementos adicionados recentemente            recent_content_script = """            () => {                const recentElements = [];                const walker = document.createTreeWalker(                    document.body,                    NodeFilter.SHOW_TEXT,                    null,                    false                );                                let node;                while (node = walker.nextNode()) {                    if (node.textContent.trim().length > 20) {                        recentElements.push(node.textContent.trim());                    }                }                                return recentElements.slice(-5).join('\n'); // Últimos 5 elementos de texto            }            """                        recent_text = await self.page.evaluate(recent_content_script)            return recent_text if recent_text else """                        except Exception as e:            logger.error(f"Erro ao extrair mudanças DOM: {e}")            return """        def _get_site_identifier(self) -> str:        """Gera identificador único para o site atual."""        if not self.page:            return "unknown"                url = self.page.url        # Remove parâmetros e fragmentos para identificação consistente        from urllib.parse import urlparse        parsed = urlparse(url)        return f"{parsed.netloc}{parsed.path}".replace('/', '_')        async def _apply_adaptation_strategy(self, strategy: AdaptationStrategy):        """Aplica estratégia de adaptação detectada."""        logger.info(f"Aplicando estratégia: {strategy.strategy_type}")                for action in strategy.actions:            action_type = action.get('type')                        if action_type == "wait_for_manual":                logger.warning("Intervenção manual necessária (CAPTCHA detectado)")                timeout = action.get('timeout', 60)                await asyncio.sleep(timeout)                            elif action_type == "rediscover_elements":                # Regenera seletores para elementos conhecidos                self.selector_generator = IntelligentSelectorGenerator()                            elif action_type == "regenerate_selectors":                # Força regeneração de seletores                self.selector_generator.selector_cache.clear()                            elif action_type == "visual_search":                # Ativa busca visual como fallback                logger.info("Ativando busca visual como fallback")        async def _collect_advanced_failure_evidence(self, error: Exception) -> Dict[str, Any]:        """Coleta evidências avançadas de falha para análise."""        evidence = {            'error_message': str(error),            'error_type': type(error).__name__,            'timestamp': datetime.now().isoformat(),            'page_info': {}        }                try:            if self.page:                # Informações da página                evidence['page_info'] = {                    'url': self.page.url,                    'title': await self.page.title(),                    'viewport': await self.page.viewport_size(),                    'user_agent': await self.page.evaluate('navigator.userAgent')                }                                # Screenshot para análise visual                screenshot = await self.page.screenshot()                evidence['screenshot_hash'] = hashlib.md5(screenshot).hexdigest()                                # Análise visual do estado atual                visual_analysis = self.vision_analyzer.analyze_page_changes(screenshot)                evidence['visual_analysis'] = visual_analysis                                # Estado do DOM                dom_content = await self.page.content()                evidence['dom_hash'] = hashlib.md5(dom_content.encode()).hexdigest()                evidence['element_count'] = len(await self.page.query_selector_all('*'))                                # Console logs e erros                evidence['console_errors'] = await self._get_console_errors()                        except Exception as e:            evidence['evidence_collection_error'] = str(e)                return evidence        async def _get_console_errors(self) -> List[Dict]:        """Coleta erros do console da página."""        # Esta seria implementada com listeners de eventos do console        # Por simplicidade, retorna lista vazia        return []        async def _attempt_recovery(self, evidence: Dict[str, Any]):        """Tenta recuperação baseada nas evidências coletadas."""        logger.info("Tentando recuperação automática...")                # Estratégias de recuperação baseadas no tipo de erro        visual_analysis = evidence.get('visual_analysis', {})                if visual_analysis.get('captcha_detected'):            logger.info("CAPTCHA detectado - aguardando resolução manual")            await asyncio.sleep(10)                            elif visual_analysis.get('bot_detection_indicators'):            logger.info("Detecção de bot - aplicando contramedidas")            await self._apply_anti_detection_measures()                            else:            # Recuperação genérica            await self._generic_recovery()        async def _apply_anti_detection_measures(self):        """Aplica medidas anti-detecção após detecção de bot."""        # Limpa cookies de tracking        await self.page.context.clear_cookies()                # Aguarda período aleatório        wait_time = np.random.uniform(5, 15)        await asyncio.sleep(wait_time)                # Simula atividade humana        await self.anti_detection.human_like_scroll(self.page, 'down', 200)        await asyncio.sleep(2)        await self.anti_detection.human_like_scroll(self.page, 'up', 100)        async def _generic_recovery(self):        """Recuperação genérica para erros não específicos."""        # Recarrega a página        await self.page.reload(wait_until='networkidle')        await asyncio.sleep(3)        def _generate_recovery_suggestions(self, evidence: Dict[str, Any]) -> List[str]:        """Gera sugestões de recuperação baseadas nas evidências."""        suggestions = []                visual_analysis = evidence.get('visual_analysis', {})                if visual_analysis.get('captcha_detected'):            suggestions.append("Resolva o CAPTCHA manualmente")            suggestions.append("Considere usar serviços de resolução de CAPTCHA")                            if visual_analysis.get('login_form_detected'):            suggestions.append("Verifique credenciais de login")            suggestions.append("Atualize processo de autenticação")                            if visual_analysis.get('layout_changes'):            suggestions.append("Site pode ter mudado - atualize seletores")            suggestions.append("Execute nova captura de baseline")                            if not suggestions:            suggestions = [                "Verifique conectividade de rede",                "Tente executar novamente após alguns minutos",                "Verifique se o site está funcionando normalmente"            ]                return suggestions        async def cleanup(self):        """Limpeza de recursos."""        try:            if self.page:                await self.page.close()            await self.browser_manager.cleanup()        except Exception as e:            logger.error(f"Erro na limpeza: {e}")# --- Gerenciador de Navegador Inteligente (Async) ---class IntelligentBrowserManager:    """Gerenciador inteligente de navegador com recursos avançados."""        def __init__(self):        self.browser: Optional[Browser] = None        self.context = None        self.page: Optional[Page] = None        self.playwright = None        async def initialize_browser(self, **config) -> Page:        """Inicializa navegador com configuração avançada."""        try:            if self.playwright is None:                self.playwright = await async_playwright().start()                        # Configurações do navegador            browser_args = [                '--disable-blink-features=AutomationControlled',                '--disable-dev-shm-usage',                '--no-sandbox',                '--disable-setuid-sandbox',                '--disable-web-security',                '--disable-extensions',                '--disable-plugins',                '--disable-images',  # Para performance                '--disable-javascript-harmony-shipping',                '--disable-background-timer-throttling',                '--disable-renderer-backgrounding',                '--disable-backgrounding-occluded-windows',                '--disable-ipc-flooding-protection',                '--window-size=1366,768'            ]                        self.browser = await self.playwright.chromium.launch(                headless=config.get('headless', True),                args=browser_args            )                        # Context com configurações anti-detecção            context_config = {                'viewport': config.get('viewport', {'width': 1366, 'height': 768}),                'user_agent': config.get('user_agent'),                'locale': config.get('locale', 'pt-BR'),                'timezone_id': config.get('timezone_id', 'America/Sao_Paulo'),                'permissions': ['geolocation', 'notifications'],                'extra_http_headers': config.get('extra_http_headers', {})            }                        self.context = await self.browser.new_context(**context_config)            self.page = await self.context.new_page()                        return self.page                        except Exception as e:            logger.error(f"Erro ao inicializar navegador: {e}")            raise        async def cleanup(self):        """Limpeza de recursos do navegador."""        try:            if self.page:                await self.page.close()            if self.context:                await self.context.close()            if self.browser:                await self.browser.close()            if self.playwright:                await self.playwright.stop()        except Exception as e:            logger.error(f"Erro na limpeza do navegador: {e}")